use base64::{Engine as _, engine::general_purpose};
use std::env;
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::Path;

const DELIMITER: &[u8] = b"\n%\xE2\x80\xA1%\n";

fn read_file<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {
    fs::read(path)
}

fn write_file<P: AsRef<Path>>(path: P, data: &[u8]) -> io::Result<()> {
    File::create(path)?.write_all(data)
}

fn find_eof_end(pdf: &[u8]) -> Option<usize> {
    let eof_marker = b"%%EOF";
    pdf.windows(eof_marker.len())
        .rposition(|window| window == eof_marker)
        .map(|pos| pos + eof_marker.len())
}

fn embed(src_pdf: &Path, payload: &Path, out_pdf: &Path) -> io::Result<()> {
    let pdf_bytes = read_file(src_pdf)?;

    let eof_end = find_eof_end(&pdf_bytes).ok_or_else(|| {
        io::Error::new(
            io::ErrorKind::InvalidData,
            "Could not locate a '%%EOF' marker in the source PDF. Are you sure this is a valid PDF file?",
        )
    })?;

    let payload_bytes = read_file(payload)?;

    let mut out = Vec::with_capacity(pdf_bytes.len() + payload_bytes.len() + 64);
    out.extend_from_slice(&pdf_bytes[..eof_end]);
    out.extend_from_slice(DELIMITER);
    out.extend_from_slice(general_purpose::STANDARD.encode(&payload_bytes).as_bytes());

    write_file(out_pdf, &out)?;

    println!(
        "✅ Embedded {} bytes into '{}', saved as '{}'.",
        payload_bytes.len(),
        src_pdf.display(),
        out_pdf.display()
    );
    Ok(())
}

fn extract(src_pdf: &Path, out_bin: &Path) -> io::Result<()> {
    let data = read_file(src_pdf)?;

    let delim_pos = data
        .windows(DELIMITER.len())
        .rposition(|w| w == DELIMITER)
        .ok_or_else(|| {
            io::Error::new(
                io::ErrorKind::NotFound,
                "Delimiter not found – this PDF does not contain a hidden payload generated by this tool.",
            )
        })?;

    let payload_start = delim_pos + DELIMITER.len();
    let payload = &data[payload_start..];

    let decoded_payload = general_purpose::STANDARD.decode(payload).map_err(|_| {
        io::Error::new(
            io::ErrorKind::InvalidData,
            "Failed to decode base64 payload. The data might be corrupted.",
        )
    })?;

    if out_bin.as_os_str() == "-" {
        let stdout = io::stdout();
        let mut handle = stdout.lock();
        handle.write_all(&decoded_payload)?;
    } else {
        write_file(out_bin, &decoded_payload)?;
        println!(
            "✅ Extracted {} bytes from '{}', saved as '{}'.",
            decoded_payload.len(),
            src_pdf.display(),
            out_bin.display()
        );
    }
    Ok(())
}

fn print_usage(program_name: &str) {
    eprintln!(
        "Usage:\n\
         {0} embed   <source.pdf> <payload.bin> <output.pdf>\n\
         {0} extract <pdf-with-payload.pdf> <output.bin>\n",
        program_name
    );
}

fn main() -> io::Result<()> {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        print_usage(&args[0]);
        std::process::exit(1);
    }

    match args[1].as_str() {
        "embed" => {
            if args.len() != 5 {
                eprintln!("Error: embed expects three arguments.");
                print_usage(&args[0]);
                std::process::exit(1);
            }
            let (src_pdf, payload, out_pdf) = (
                Path::new(&args[2]),
                Path::new(&args[3]),
                Path::new(&args[4]),
            );
            embed(src_pdf, payload, out_pdf)?;
        }
        "extract" => {
            if args.len() != 4 {
                eprintln!("Error: extract expects two arguments.");
                print_usage(&args[0]);
                std::process::exit(1);
            }
            let (src_pdf, out_bin) = (
                Path::new(&args[2]),
                Path::new(&args[3]),
            );
            extract(src_pdf, out_bin)?;
        }
        _ => {
            eprintln!("Error: unknown sub‑command '{}'.", args[1]);
            print_usage(&args[0]);
            std::process::exit(1);
        }
    }

    Ok(())
}
